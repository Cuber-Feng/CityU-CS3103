# Page Replacement Policy

> 🧠 什么是 Page Replacement？
> 
> 当一个进程访问某个不在物理内存中的页面（即发生 **Page Fault**），操作系统需要从磁盘把该页面加载到物理内存中。但是如果内存已满，就必须选择一个**已经在内存中的页面**来换出（也就是写回磁盘），然后把新的页面放进来。
> 
> 这个“选择哪一个页面来换出”的策略，就是 **Page Replacement Policy（页置换策略）**。

## 🏷️ 常见的 Page Replacement 策略

### 1. **FIFO（First-In-First-Out）先进先出**

- 思路：最早进入内存的页面最早被换出。

- 实现简单：使用队列。

- 缺点：可能会出现“Belady’s Anomaly”（增加页数反而更多Page Fault）。

### 2. **LRU（Least Recently Used）最近最少使用**

- 思路：换出**最久没有被访问**的页面。

- 假设：最近使用的页面可能还会继续被使用。

- 实现方式：
  
  - 用栈（不现实，开销大）
  
  - 计数器或链表（性能折中）

### 3. **OPT（Optimal / Belady’s Algorithm）最优置换**

- 思路：换出**未来最久不会被访问**的页面。

- 理论上最优，但无法实现（因为操作系统无法预测未来）。

- 用于评估其他算法性能的基准。

### 4. **Clock（近似 LRU）**

- LRU 的近似实现，用一个“时钟指针”。

- 给每个页面一个 reference bit（引用位），初始设为 1。

- 扫描时如果引用位为 0，则换出；否则设为 0，跳过。

- 效率较高，是很多实际系统的选择（如 Linux 的 Second Chance 算法）

---

## 🧾 什么是 Dirty Bit？

- **Dirty Bit（脏位）**：是操作系统在页表（Page Table）中为每个页面设置的一个标志位

- 当一个页面被 **写入(修改)** 过之后，它的 dirty bit 就会被设置为 `1`（true），表示这个页面已经**被修改过了**，它现在的内容和磁盘上的原始副本**不一致**了。

- 如果 **dirty bit = 1**：这个页面已经被改过了，必须要**写回磁盘**，否则数据会丢失。

- 如果 **dirty bit = 0**：说明页面内容和磁盘上的一致，可以**直接丢弃**，不用写回磁盘，速度更快

---

## 🧠 Prefetching 是什么？

- 还没用到，先帮你拿过来。

- 系统**提前加载可能将来会用到的数据**（比如内存页面），到缓存或主内存中

---

## 💥 什么是 Thrashing？

- 一个系统因为频繁发生 **Page Fault（页错误）**，而导致 CPU 大量时间都浪费在 **页面换入换出（page in / page out）** 上，进程根本没干实际工作

#### 😨 Thrashing 的表现：

- Page Fault 率飙升 🚨

- CPU 利用率下降 📉

- 系统反应极慢甚至假死 🧊

- 磁盘疯狂转、风扇狂转，因为在疯狂换页 💽💨
